"""Synthetic configuration file generation for testing.

This module generates synthetic config.toml and session.toml files that are
valid according to the W2T-BKIN schema and can be used for testing.

Features:
---------
- Generate valid config.toml with all required sections
- Generate valid session.toml with cameras, TTLs, and Bpod
- Template-based generation with parameter substitution
- Deterministic output for reproducible tests

Requirements Coverage:
----------------------
- FR-10: Configuration file generation for tests
- NFR-10/11: Valid configuration validation
"""

from pathlib import Path
from typing import List, Optional

from synthetic.models import SyntheticCamera, SyntheticSessionParams, SyntheticTTL


def create_config_toml(
    output_path: Path,
    raw_root: Path,
    processed_root: Path,
    temp_root: Path,
    timebase_source: str = "ttl",
    timebase_mapping: str = "nearest",
    timebase_ttl_id: Optional[str] = None,
    jitter_budget_s: float = 0.005,
) -> Path:
    """Create a synthetic config.toml file.

    Args:
        output_path: Path where config.toml should be written
        raw_root: Path to raw data root directory
        processed_root: Path to processed data directory
        temp_root: Path to temporary files directory
        timebase_source: Timebase source (nominal_rate, ttl, neuropixels)
        timebase_mapping: Mapping strategy (nearest, linear)
        timebase_ttl_id: TTL ID for timebase (required if source='ttl')
        jitter_budget_s: Maximum allowed jitter in seconds

    Returns:
        Path to created config.toml file

    Example:
        >>> from pathlib import Path
        >>> config_path = create_config_toml(
        ...     Path("config.toml"),
        ...     raw_root=Path("data/raw"),
        ...     processed_root=Path("data/processed"),
        ...     temp_root=Path("temp"),
        ...     timebase_source="ttl",
        ...     timebase_ttl_id="cam0_ttl"
        ... )
    """
    output_path.parent.mkdir(parents=True, exist_ok=True)

    # Build timebase section
    timebase_section = f"""
[timebase]
source = "{timebase_source}"
mapping = "{timebase_mapping}"
jitter_budget_s = {jitter_budget_s}
"""
    if timebase_source == "ttl" and timebase_ttl_id:
        timebase_section += f'ttl_id = "{timebase_ttl_id}"\n'
    elif timebase_source == "neuropixels":
        timebase_section += 'neuropixels_stream = "neuropixels_stream"\n'

    # Build full config content
    config_content = f"""# Synthetic config.toml for testing
# Generated by synthetic.config_synth

[project]
name = "w2t-bkin-test"

[paths]
raw_root = "{raw_root.as_posix()}"
intermediate_root = "{processed_root.as_posix()}/interim"
output_root = "{processed_root.as_posix()}"
metadata_file = "session.toml"
models_root = "models"
{timebase_section}
[acquisition]
concat_strategy = "ffconcat"

[verification]
mismatch_tolerance_frames = 5
warn_on_mismatch = false

[bpod]
parse = true

[video.transcode]
enabled = false
codec = "h264"
crf = 20
preset = "fast"
keyint = 15

[nwb]
link_external_video = true
lab = "Test Lab"
institution = "Test Institution"
file_name_template = "{{session.id}}.nwb"
session_description_template = "Session {{session.id}} on {{session.date}}"

[qc]
generate_report = true
out_template = "qc/{{session.id}}"
include_verification = true

[logging]
level = "INFO"
structured = false

[labels.dlc]
run_inference = false
model = "model.pb"

[labels.sleap]
run_inference = false
model = "sleap.h5"

[facemap]
run_inference = false
ROIs = ["face", "left_eye", "right_eye"]
"""

    with open(output_path, "w") as f:
        f.write(config_content)

    return output_path


def create_session_toml(
    output_path: Path,
    params: SyntheticSessionParams,
    cameras: List[SyntheticCamera],
    ttls: List[SyntheticTTL],
    video_files_per_camera: Optional[dict[str, List[str]]] = None,
    ttl_files_per_ttl: Optional[dict[str, str]] = None,
    bpod_files: Optional[List[str]] = None,
) -> Path:
    """Create a synthetic session.toml file.

    Args:
        output_path: Path where session.toml should be written
        params: Session parameters (session_id, subject_id, etc.)
        cameras: List of camera configurations
        ttls: List of TTL configurations
        video_files_per_camera: Dictionary mapping camera_id to list of video filenames
        ttl_files_per_ttl: Dictionary mapping ttl_id to TTL filename
        bpod_files: List of Bpod .mat filenames

    Returns:
        Path to created session.toml file

    Example:
        >>> from pathlib import Path
        >>> from synthetic.models import SyntheticSessionParams, SyntheticCamera, SyntheticTTL
        >>> params = SyntheticSessionParams(
        ...     session_id="test-001",
        ...     subject_id="test-subject",
        ...     experimenter="test-experimenter",
        ... )
        >>> cameras = [SyntheticCamera(camera_id="cam0", ttl_id="cam0_ttl")]
        >>> ttls = [SyntheticTTL(ttl_id="cam0_ttl", pulse_count=100)]
        >>> session_path = create_session_toml(
        ...     Path("session.toml"),
        ...     params,
        ...     cameras,
        ...     ttls,
        ... )
    """
    output_path.parent.mkdir(parents=True, exist_ok=True)

    # Build session metadata section
    session_content = f"""# Synthetic session.toml for testing
# Generated by synthetic.config_synth

[session]
id = "{params.session_id}"
subject_id = "{params.subject_id}"
date = "{params.date}"
experimenter = "{params.experimenter}"
description = "Synthetic test session"
sex = "M"
age = "P60"
genotype = "WT"
"""

    # Build Bpod section if files provided
    if bpod_files:
        session_content += "\n[bpod]\n"
        session_content += f'path = "{bpod_files[0]}"\n'
        session_content += 'order = "name_asc"\n'

        # Provide default trial_types sync configuration for synthetic sessions
        # This makes examples and tests simpler: they can directly use
        # session.bpod.trial_types for Bpodâ€“TTL alignment.
        # Note: sync_ttl refers to a dedicated TTL channel that records Bpod sync pulses,
        # NOT the camera TTL. This should be a separate TTL line (e.g., "bpod_d1_ttl").
        session_content += "\n  [[bpod.trial_types]]\n"
        session_content += "  trial_type = 1\n"
        session_content += '  description = "Synthetic default trial type"\n'
        session_content += '  sync_signal = "bpod_d1"\n'
        session_content += '  sync_ttl = "bpod_d1_ttl"\n'
    else:
        # Bpod section is required, even if empty/placeholder
        session_content += "\n[bpod]\n"
        session_content += 'path = "Bpod/*.mat"\n'
        session_content += 'order = "name_asc"\n'

    # Build TTLs section (always required in schema)
    if ttls:
        for ttl in ttls:
            session_content += f"\n[[TTLs]]\n"
            session_content += f'id = "{ttl.ttl_id}"\n'
            session_content += f'description = "Synthetic TTL for {ttl.ttl_id}"\n'

            # Add TTL file path if provided
            if ttl_files_per_ttl and ttl.ttl_id in ttl_files_per_ttl:
                session_content += f'paths = "{ttl_files_per_ttl[ttl.ttl_id]}"\n'
            else:
                session_content += 'paths = "TTLs/*.txt"\n'
    else:
        # Schema requires at least one TTL, add a placeholder
        session_content += "\n[[TTLs]]\n"
        session_content += 'id = "placeholder_ttl"\n'
        session_content += 'description = "Placeholder TTL (not used)"\n'
        session_content += 'paths = "TTLs/*.txt"\n'

    # Build cameras section
    for camera in cameras:
        session_content += f"\n[[cameras]]\n"
        session_content += f'id = "{camera.camera_id}"\n'
        session_content += f'description = "Synthetic camera {camera.camera_id}"\n'
        session_content += 'order = "name_asc"\n'

        # ttl_id is required
        if camera.ttl_id:
            session_content += f'ttl_id = "{camera.ttl_id}"\n'
        else:
            # Use placeholder TTL if camera has no TTL
            session_content += 'ttl_id = "placeholder_ttl"\n'

        # Add video file paths if provided
        if video_files_per_camera and camera.camera_id in video_files_per_camera:
            # Use glob pattern for paths
            video_pattern = video_files_per_camera[camera.camera_id][0]
            session_content += f'paths = "{video_pattern}"\n'

    with open(output_path, "w") as f:
        f.write(session_content)

    return output_path
